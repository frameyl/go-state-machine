package common

import (
	"bytes"
	//"io"
	"log"
	"time"
	"fmt"
	"github.com/looplab/fsm"
)

// OutputChan is the channel for sending packets out
var OutputChan chan bytes.Buffer

// Session defines a session for SSMP
type Session struct {
	Id    int    //unique identifer, internally used
	Magic uint64 //Magic Number generated by client
	Svrid string //Server ID
	Sid   uint32 //Session ID allocated by Server
	
	// packet recv channel, with packet goroutine
	BufChan chan bytes.Reader
	// Control channel (start, reset, clean), with scheduler goroutine
	CntlChan chan int
	// Counters
	SessionCnt
	// FSM (looplab style)
	fsm *fsm.FSM
}

type SessionClient struct {
	Session
	retryTimer *time.Timer
	deadTimer *time.Timer
	SessionClientCnt
}

type SessionServer struct {
	Session
	deadTimer *time.Timer
	SessionServerCnt
}

type SessionCnt struct {
	Tx      int
	TxHello int
	TxDisc  int
	Rx      int
	RxHello int
	RxDisc  int
	Retry   int
}

type SessionClientCnt struct {
	TxRequest int
	TxConfirm int
	RxReply   int
}

type SessionServerCnt struct {
	TxReply   int
	RxRequest int
	RxConfirm int
}

type SessionCmd int

const (
	// Command for FSM
	S_CMD_NOTHING = iota
	S_CMD_START
	S_CMD_STOP
	S_CMD_PAUSE
	S_CMD_CONTINUE
	S_CMD_CLEAN
	// The following is internal command
	//FSM_CMD_TIMEOUT
	//FSM_CMD_WAIT
	//FSM_CMD_RETRY
)

// send*() define a serial of functions to send protocol packets out
//
// sendPacket():	General call
// sendHello():		Send Hello packets
// sendRequest():	Send Request packets (clinet only)
// sendConfirm():	Send Confirm packets (client only)
// sendClose():		Send Close packets (client or server)
// sendReply():		Send Reply packets (server only)
func (s *Session) sendPacket(mtype MsgType) error {
	buf := new(bytes.Buffer)
	WritePacketHdr(buf, mtype, s.Magic, s.Svrid)
	pktLen := LEN_SSMP_HDR

	if mtype == MSG_REPLY || mtype == MSG_CONFIRM || mtype == MSG_CLOSE {
		WriteSessionID(buf, s.Sid)
		pktLen += LEN_SESSION_ID
	}

	OutputChan <- *buf

	return nil
}

func (s *Session) sendHello() error {
	return s.sendPacket(MSG_HELLO)
}

func (s *Session) sendRequest() error {
	return s.sendPacket(MSG_REQUEST)
}

func (s *Session) sendConfirm() error {
	return s.sendPacket(MSG_CONFIRM)
}

func (s *Session) sendClose() error {
	return s.sendPacket(MSG_CLOSE)
}

func (s *Session) sendReply() error {
	return s.sendPacket(MSG_REPLY)
}

const SESSION_TIMEOUT_RETRY = 2
const SESSION_TIMEOUT_DEAD = 5

// Timer functions:
//		retryTimerOn
//		retryTimerOff
//		deadTimerOn
//		deadTimerOff
func (cs *SessionClient) retryTimerOn() error {
	cs.retryTimer = time.NewTimer(SESSION_TIMEOUT_RETRY * time.Second)
	return nil
}

func (cs *SessionClient) retryTimerOff() error {
	if cs.retryTimer.Stop() == false {
		return fmt.Errorf("Failed to stop retry timer, id %d", cs.Id)
	}
	
	return nil
}

func (cs *SessionClient) deadTimerOn() error {
	cs.deadTimer = time.NewTimer(SESSION_TIMEOUT_DEAD * time.Second)
	return nil
}

func (cs *SessionClient) deadTimerOff() error {
	if cs.deadTimer.Stop() == false {
		return fmt.Errorf("Failed to stop dead timer, id %d", cs.Id)
	}
	return nil
}

func (ss *SessionServer) deadTimerOn() error {
	ss.deadTimer = time.NewTimer(SESSION_TIMEOUT_DEAD * time.Second)
	return nil
}

func (ss *SessionServer) deadTimerOff() error {
	if ss.deadTimer.Stop() == false {
		return fmt.Errorf("Failed to stop dead timer, id %d", ss.Id)
	}
	return nil
}

// enterState is a callback and will be called once a state transaction happens
func (s *Session) enterState(e *fsm.Event) {
	log.Println("Session", s.Id, "Entering state", s.fsm.Current(), "with Event", e.Event)
}

// connected is a callback and will be called once the session connects
func (s *Session) connected(e *fsm.Event) {
	log.Println("Session", s.Id, "Connected", "with Event", e.Event)
	return
}

func (s *Session) disconnected(e *fsm.Event) {
	log.Println("Session", s.Id, "Disconnected", "with Event", e.Event)
	return
}

func (s *Session) clean(e *fsm.Event) {
	log.Println("Session", s.Id, "cleaned", "with Event", e.Event)
	
	// Clean SrvID, Magic
	s.Svrid = ""
	s.Sid = 0
	s.Magic = 0
	
	return
}

// retryTimeout is a callback and will be called after a retry timer expired
func (s *SessionClient) retryTimeout(e *fsm.Event) {
	log.Println("Session", s.Id, "retry Timer expired")
	
	current := s.fsm.Current()
	switch current {
	case "init":
		s.sendHello()
		
	case "req":
		s.sendRequest()
		
	case "close":
		s.sendClose()
		
	default:
		log.Println("Invalide state when retry timer expired.")
		return
	}
	
	s.SessionCnt.Retry++
	s.retryTimerOn()
	
	return
}

func (s *SessionClient) deadTimeout(e *fsm.Event) {
	log.Println("Session", s.Id, "dead Timer expired")
	
	current := s.fsm.Current()
	switch current {
	case "init", "req", "close":
		// Clean SrvID, Magic
		s.Svrid = ""
		s.Sid = 0
		s.Magic = 0
		
	default:
		log.Println("Invalide state when dead timer expired.")
		return
	}	
	
	return
}

func (s *SessionServer) deadTimeout(e *fsm.Event) {
	log.Println("Session", s.Id, "cleaned", "with Event", e.Event)

	current := s.fsm.Current()
	switch current {
	case "allocated":
		// Clean Magic
		s.Magic = 0
		
	default:
		log.Println("Invalide state when dead timer expired.")
		return
	}	
	
	return
}

func NewClientSession(id int) *SessionClient {
	s := &SessionClient{
		Session: Session {
			Id: id,
			BufChan: make(chan bytes.Reader, 2),
			CntlChan: make(chan int),
		},
	}

	s.fsm = fsm.NewFSM(
		"idle",
		fsm.Events{
			{Name: "start", Src: []string{"idle"}, Dst: "init"},
			
			{Name: "stop", Src: []string{"init"}, Dst: "close"},
			{Name: "stop", Src: []string{"req", "est"}, Dst: "close"},
			
			{Name: "hello_received", Src: []string{"init"}, Dst: "req"},
			
			{Name: "reply_received", Src: []string{"req"}, Dst: "est"},
						
			{Name: "disconnect_received", Src: []string{"init"}, Dst: "idle"},
			{Name: "disconnect_received", Src: []string{"req"}, Dst: "idle"},
			{Name: "disconnect_received", Src: []string{"est"}, Dst: "idle"},

			{Name: "pause", Src: []string{"init"}, Dst: "init"},
			{Name: "pause", Src: []string{"req"}, Dst: "req"},
			{Name: "pause", Src: []string{"est"}, Dst: "est"},
			{Name: "pause", Src: []string{"close"}, Dst: "close"},
			{Name: "continue", Src: []string{"init"}, Dst: "init"},
			{Name: "continue", Src: []string{"req"}, Dst: "req"},
			{Name: "continue", Src: []string{"est"}, Dst: "est"},
			{Name: "continue", Src: []string{"close"}, Dst: "close"},
			
			{Name: "clean", Src: []string{"idle", "init", "req", "est", "close"}, Dst: "idle"},
			
			{Name: "retry_timeout", Src: []string{"init"}, Dst: "init"},
			{Name: "retry_timeout", Src: []string{"req"}, Dst: "req"},
			{Name: "retry_timeout", Src: []string{"est"}, Dst: "est"},
			{Name: "retry_timeout", Src: []string{"close"}, Dst: "close"},

			{Name: "dead_timeout", Src: []string{"init", "req", "est", "close"}, Dst: "idle"},
		},
		fsm.Callbacks{
			"enter_state": func(e *fsm.Event) { s.enterState(e) },
			"enter_idle": func(e *fsm.Event) { s.disconnected(e) },
			"enter_init": func(e *fsm.Event) { s.sendHello(); s.retryTimerOn(); s.deadTimerOn() },
			"enter_req": func(e *fsm.Event) { s.sendRequest(); s.retryTimerOn(); s.deadTimerOn() },
			"enter_est": func(e *fsm.Event) { s.sendConfirm(); s.connected(e) },
			"enter_close": func(e *fsm.Event) { s.sendClose(); s.retryTimerOn(); s.deadTimerOn() },

			"leave_init": func(e *fsm.Event) { s.retryTimerOff(); s.deadTimerOff() },
			"leave_req": func(e *fsm.Event) { s.retryTimerOff(); s.deadTimerOff() },
			"leave_close": func(e *fsm.Event) { s.retryTimerOff(); s.deadTimerOff() },
			
			"before_hello_received": func(e *fsm.Event) { s.recvHello(e) },
			"before_reply_received": func(e *fsm.Event) { s.recvReply(e) },
			
			"after_pause": func(e *fsm.Event) { s.retryTimerOff(); s.deadTimerOff() },
			"after_continue": func(e *fsm.Event) { s.retryTimerOn(); s.deadTimerOn() },
			
			"after_clean": func(e *fsm.Event) { s.clean(e) },
			
			"after_retry_timeout": func(e *fsm.Event) { s.retryTimeout(e) },
			"after_dead_timeout": func(e *fsm.Event) { s.deadTimeout(e) },
		},
	)
	return s
}

func (s *SessionClient) RunClient() {
	for {
		select {
		case <-s.retryTimer.C:
			s.fsm.Event("retry_timeout")
		case <-s.deadTimer.C:
			s.fsm.Event("dead_timeout")
		case cmd := <-s.CntlChan:
			if cmd == S_CMD_START {
				s.fsm.Event("start")
			} else if cmd == S_CMD_STOP {
				s.fsm.Event("stop")
			} else if cmd == S_CMD_PAUSE {
				s.fsm.Event("pause")
			} else if cmd == S_CMD_CONTINUE {
				s.fsm.Event("continue")
			} else if cmd == S_CMD_CLEAN {
				s.fsm.Event("clean")
			} else {
				log.Println("Invalide command received", cmd)
			}
		case pkt := <-s.BufChan:
			// got a packet here
			s.Rx++
			msgType, _ := ReadMsgType(&pkt)
			if msgType == MSG_HELLO {
				s.fsm.Event("hello_received", &pkt)
			} else if msgType == MSG_REPLY {
				s.fsm.Event("reply_received", &pkt)
			} else {
				log.Println("Invalid package received, type", msgType)
			}
		}
	}
}

func (s *SessionClient) recvHello(e *fsm.Event) {
	var pkt *bytes.Reader
	pkt = e.Args[0].(*bytes.Reader)
	
	s.RxHello++
	magic, _ := ReadMagicNum(pkt)
	if magic != s.Magic {
		log.Println("Wrong Magic number", s.Magic)
		e.Cancel()
		return
	}
	
	s.Svrid, _ = ReadServerID(pkt)
	return
}

func (s *SessionClient) recvReply(e *fsm.Event) {
	var pkt *bytes.Reader
	pkt = e.Args[0].(*bytes.Reader)
	
	s.RxReply++
	magic, _ := ReadMagicNum(pkt)
	if magic != s.Magic {
		log.Println("Wrong Magic number", s.Magic)
		e.Cancel()
		return
	}
	
	svrid, _ := ReadServerID(pkt)
	if svrid != s.Svrid {
		log.Println("Wrong Server ID", s.Svrid)
		e.Cancel()
		return
	}
	
	s.Sid, _ = ReadSessionID(pkt)
	return
}

func NewServerSession(id int, sid uint32, svrid string, magic uint64) *SessionServer {
	s := &SessionServer{
		Session: Session{
			Id: id,
			Sid: sid,
			Svrid: svrid,
			Magic: magic,
			BufChan: make(chan bytes.Reader, 2),
			CntlChan: make(chan int),
		},
	}

	s.fsm = fsm.NewFSM(
		"idle",
		fsm.Events{
			{Name: "start", Src: []string{"idle"}, Dst: "listening"},
			{Name: "stop", Src: []string{"listening", "allocated", "est"}, Dst: "idle"},
			{Name: "request_received", Src: []string{"listening"}, Dst: "allocated"},
			{Name: "confirm_received", Src: []string{"allocated"}, Dst: "est"},
			{Name: "close_received", Src: []string{"est"}, Dst: "listening"},
			
			{Name: "pause", Src: []string{"allocated"}, Dst: "allocated"},
			{Name: "continue", Src: []string{"allocated"}, Dst: "allocated"},
			
			{Name: "clean", Src: []string{"idle", "listening", "allocated", "est"}, Dst: "idle"},
			
			{Name: "dead_timeout", Src: []string{"allocated", "est"}, Dst: "listening"},
		},
		fsm.Callbacks{
			"enter_state": func(e *fsm.Event) { s.enterState(e) },
			"enter_idle": func(e *fsm.Event) { s.disconnected(e) },
			"enter_listening": func(e *fsm.Event) { /*s.registerSession(e)*/ },
			"enter_allocated": func(e *fsm.Event) { s.sendReply(); s.deadTimerOn() },
			"enter_est": func(e *fsm.Event) { s.connected(e) },

			"leave_allocated": func(e *fsm.Event) { s.deadTimerOff() },

			"before_request_received": func(e *fsm.Event) { s.recvRequest(e) },
			"before_confirm_received": func(e *fsm.Event) { s.recvConfirm(e) },
			"before_close_received": func(e *fsm.Event) { s.recvClose(e) },
			
			"after_close_received": func(e *fsm.Event) { s.sendClose() },
			
			"after_stop": func(e *fsm.Event) { },
			"after_pause": func(e *fsm.Event) { s.deadTimerOff() },
			"after_continue": func(e *fsm.Event) { s.deadTimerOn() },
			
			"after_clean": func(e *fsm.Event) { s.clean(e) },
			
			"after_dead_timeout": func(e *fsm.Event) { s.deadTimeout(e) },
		},
	)
	return s
}

func (s *SessionServer) RunServer() {
	for {
		select {
		case <-s.deadTimer.C:
			s.fsm.Event("dead_timeout")
		case cmd := <-s.CntlChan:
			if cmd == S_CMD_START {
				s.fsm.Event("start")
			} else if cmd == S_CMD_STOP {
				s.fsm.Event("stop")
			} else if cmd == S_CMD_PAUSE {
				s.fsm.Event("pause")
			} else if cmd == S_CMD_CONTINUE {
				s.fsm.Event("continue")
			} else if cmd == S_CMD_CLEAN {
				s.fsm.Event("clean")
			} else {
				log.Println("Invalide command received", cmd)
			}
		case pkt := <-s.BufChan:
			// got a packet here
			s.Rx++
			msgType, _ := ReadMsgType(&pkt)
			if msgType == MSG_REQUEST {
				s.fsm.Event("request_received", &pkt)
			} else if msgType == MSG_CONFIRM {
				s.fsm.Event("confirm_received", &pkt)
			} else if msgType == MSG_CLOSE {
				s.fsm.Event("disconnect_received", &pkt)
			} else {
				log.Println("Invalid package received, type", msgType)
			}
		}
	}
}

func (s *SessionServer) recvRequest(e *fsm.Event) {
	var pkt *bytes.Reader
	pkt = e.Args[0].(*bytes.Reader)
	
	s.RxRequest++
	magic, _ := ReadMagicNum(pkt)
	if magic != s.Magic {
		log.Println("Wrong Magic number", s.Magic)
		e.Cancel()
		return
	}
	
	svrid, _ := ReadServerID(pkt)
	if svrid != s.Svrid {
		log.Println("Wrong Server ID", s.Svrid)
		e.Cancel()
		return
	}
	
	return
}

func (s *SessionServer) recvConfirm(e *fsm.Event) {
	var pkt *bytes.Reader
	pkt = e.Args[0].(*bytes.Reader)
	
	s.RxConfirm++
	magic, _ := ReadMagicNum(pkt)
	if magic != s.Magic {
		log.Println("Wrong Magic number", s.Magic)
		e.Cancel()
		return
	}
	
	svrid, _ := ReadServerID(pkt)
	if svrid != s.Svrid {
		log.Println("Wrong Server ID", s.Svrid)
		e.Cancel()
		return
	}
	
	sid, _ := ReadSessionID(pkt)
	if sid != s.Sid {
		log.Println("Wrong Session ID", s.Sid)
		e.Cancel()
		return
	}

	return
}

func (s *SessionServer) recvClose(e *fsm.Event) {
	var pkt *bytes.Reader
	pkt = e.Args[0].(*bytes.Reader)
	
	s.RxConfirm++
	magic, _ := ReadMagicNum(pkt)
	if magic != s.Magic {
		log.Println("Wrong Magic number", s.Magic)
		e.Cancel()
		return
	}
	
	svrid, _ := ReadServerID(pkt)
	if svrid != s.Svrid {
		log.Println("Wrong Server ID", s.Svrid)
		e.Cancel()
		return
	}
	
	sid, _ := ReadSessionID(pkt)
	if sid != s.Sid {
		log.Println("Wrong Session ID", s.Sid)
		e.Cancel()
		return
	}

	return
}

/*
const (
	FSM_STATE_IDLE = iota
	FSM_STATE_INIT
	FSM_STATE_REQ
	FSM_STATE_EST
	FSM_STATE_CLOSE
)

const FSM_RETRY = 5
const FSM_TIMEOUT = 3


type stateFn func(*Fsm) stateFn

func (fsm *Fsm) RunClient() {
	for state := Initial; state != nil; {
		state = state(fsm)
	}

	close(fsm.BufChan)
	close(fsm.CntlChan)
}

func (fsm *Fsm) SendPacket(mtype MsgType) error {
	buf := new(bytes.Buffer)
	WritePacketHdr(buf, mtype, fsm.Magic, fsm.Svrid)
	pktLen := LEN_SSMP_HDR

	if mtype == MSG_REPLY || mtype == MSG_CONFIRM || mtype == MSG_CLOSE {
		WriteSessionID(buf, fsm.Sid)
		pktLen += LEN_SESSION_ID
	}

	FsmWrite <- *buf

	return nil
}

func (fsm *Fsm) WaitForPacket(mtype MsgType, timer *time.Timer) (*bytes.Reader, FsmCmd) {
	select {
	case <-timer.C:
		return nil, FSM_CMD_TIMEOUT
	case pkt := <-fsm.BufChan:
		fsm.Rx++
		msgType, _ := ReadMsgType(&pkt)
		if msgType != mtype {
			return &pkt, FSM_CMD_WAIT
		}
		return &pkt, FSM_CMD_NOTHING
	case cmd := <-fsm.CntlChan:
		if cmd == FSM_CMD_PAUSE {
			timer.Stop()
		} else if cmd == FSM_CMD_RESET {
			timer = time.NewTimer(FSM_TIMEOUT * time.Second)
		}
		return nil, FsmCmd(cmd)
	}
	return nil, FSM_CMD_NOTHING
}

func Initial(fsm *Fsm) stateFn {
	fsm.State = FSM_STATE_INIT
	// Send Hello packet periodicly, to Requesting phase once it get a hello from server with server id
	for i := 0; i < FSM_RETRY; {
		if err := fsm.SendPacket(MSG_HELLO); err != nil {
			i++
			log.Printf("%s", err)
			continue
		}

		fsm.Tx++
		fsm.TxHello++
		timer := time.NewTimer(FSM_TIMEOUT * time.Second)
		defer timer.Stop()

		for {
			pkt, cmd := fsm.WaitForPacket(MSG_HELLO, timer)
			if pkt != nil && cmd == FSM_CMD_NOTHING {
				fsm.RxHello++
				magic, _ := ReadMagicNum(pkt)
				if magic != fsm.Magic {
					continue
				}
				fsm.Svrid, _ = ReadServerID(pkt)
				fsm.NextState = FSM_STATE_REQ
				return Requesting
			}
			if cmd == FSM_CMD_WAIT {
				continue
			} else if cmd == FSM_CMD_CLEAN {
				log.Printf("FSM#%v Got Clean command", fsm.Id)
				fsm.NextState = FSM_STATE_IDLE
				return nil
			} else {
				i++
				break
			}
		}

		fsm.Retry++
	}

	log.Printf("FSM#%v Initial Failed", fsm.Id)
	fsm.NextState = FSM_STATE_IDLE
	return nil
}

func Requesting(fsm *Fsm) stateFn {
	// Send Request packet periodicly, to Established phase once it get a reply from server
	fsm.State = FSM_STATE_REQ
	return Established
}

func Established(fsm *Fsm) stateFn {
	// Doing nothing until it get a disconnect command
	fsm.State = FSM_STATE_EST
	return Closing
}

func Closing(fsm *Fsm) stateFn {
	// Send disconnect packet periodicly, to Initial state once it get a disconnect from server
	fsm.State = FSM_STATE_CLOSE
	return nil
}
*/
